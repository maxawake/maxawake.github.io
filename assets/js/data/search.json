[
  
  {
    "title": "Vlasov Simulation in Python",
    "url": "/maxawake/posts/vlasov_simulation/",
    "categories": "Simulation, Tutorial",
    "tags": "simulation",
    "date": "2019-08-08 05:33:00 +0200",
    





    
    "snippet": "In this tutorial we want to simulate a stream of electrons in the Pierce Diode in one dimension using the electrostatic Vlasov-Poisson Equation. When simulating such a scenario, usually computation...",
    "content": "In this tutorial we want to simulate a stream of electrons in the Pierce Diode in one dimension using the electrostatic Vlasov-Poisson Equation. When simulating such a scenario, usually computational plasma physicists use either the fluid discription of plasmas, called Magneto Hydrodynmaics (MHD), or the semi-lagrangian Particle-In-Cell method to simulate the Vlasov equation. However, both approaches have their drawbacks. For example, the MHD theory is based on a few but fundamental assumptions which break down in certain, very interesting, regimes. PIC on the other hand does not have the limits on e.g.resitivity but needs a computationally very intensive amount of particles to generate solutions with a reasonable low amount of noise at a given space-time resolution.import tqdmimport cmasherimport numpy as npimport matplotlib.pyplot as pltplt.style.use(\"dark\")plt.style.use({'figure.facecolor': '#111213'})The idea of simulating the Vlasov equation is to directly evolve the distribution function, which is a 6+1 dimensional scalar function of position and velocity. Formally it can be written as\\[\\frac{\\mathrm{d}}{\\mathrm{d}t} f(\\vec{x},\\vec{v},t) = 0\\]Usually there are two distribution functions, one for ions and one for electrons. But as we only want to simulate electron dynamics we can omit the ion part here. Taking the total time derivative using the chain rule we find the plasma kinetic equation\\[\\frac{\\mathrm{d}}{\\mathrm{d}t} f=\\frac{\\partial f}{\\partial t}+\\frac{\\partial x}{\\partial t}\\frac{\\partial f}{\\partial x}+\\frac{\\partial v}{\\partial t}\\frac{\\partial f}{\\partial v}=0\\]By identifying $\\frac{\\partial x}{\\partial t}=v$ and $\\frac{\\partial v}{\\partial t}=a$ and using the equation for electrostatic force $F_E=m_ea=q_e E$ we derived the 1D Vlasov-Poisson equation:\\[\\frac{\\partial f}{\\partial t}+v\\frac{\\partial f}{\\partial x}+\\frac{q_\\alpha E}{m}\\frac{\\partial f}{\\partial v}=0\\]This is generally a hyperbolic conservation law and can be computed numerically by employing standard techniques of solving partial differential equation like the Lax-Wendroff scheme or similar. In this tutorial we use the very simple upwind scheme.The final missing ingredient to solve the Vlasov equation is the electric field. The problem is that if we want to simulate moving electrons in principle we have to solve the full Maxwell system of equations, containing E and B fields. In our case however we can neglegt the contribution of the magnetic field and calculate the electric field simply from the Poission equation using the charge density distribution $\\rho$. First we know that the divergence of the electric field equals the charge density\\[\\nabla\\cdot E=4\\pi\\rho\\]The charge density can simply be found as the first moment of the Vlasov equation, hence\\[\\rho(x,t)=q_e\\int f(x,v,t) \\mathrm{d}v\\]ImplementationTo run the simulation of the Vlasov equation on a computer we have to implement a finite difference scheme. As our programming language of choice is python, we have to take special care on performance. This obscures the readability of the code but makes python code run nearly as fast as C code.We start by implementing gradients and laplacians in matrix form. The gradient can be approximated by central differences\\[\\frac{\\partial f(x)}{\\partial x}\\approx\\frac{f(x+h)-f(x-h)}{2h}\\]The corresponding matrix using periodic boundary condition is thus\\[\\begin{pmatrix}0 &amp; 1/2 &amp; 0 &amp; ... &amp; -1/2\\\\ -1/2 &amp; 0 &amp; 1/2 &amp; ... &amp; 0\\\\ \\cdots &amp;&amp;&amp;&amp; \\\\ 1/2 &amp;0&amp;0&amp; ... &amp; 0\\end{pmatrix}\\]def gradient(n):    matrix = np.diag(np.ones(n)*0)    matrix += np.diag(np.ones(n-1)*0.5, 1)    matrix += np.diag(np.ones(n-1)*-0.5, -1)    matrix[0,-1] = -0.5    matrix[-1,0] = 0.5    return matrixprint(gradient(6))[[ 0.   0.5  0.   0.   0.  -0.5] [-0.5  0.   0.5  0.   0.   0. ] [ 0.  -0.5  0.   0.5  0.   0. ] [ 0.   0.  -0.5  0.   0.5  0. ] [ 0.   0.   0.  -0.5  0.   0.5] [ 0.5  0.   0.   0.  -0.5  0. ]]The Laplacian $\\Delta$ in 1D can be approximated by central differences as well, yielding\\[\\Delta f(x)=\\frac{\\partial^2 f(x)}{\\partial x^2}\\approx\\frac{f(x+h)-2f(x)+f(x-h)}{h^2}\\]with corresponding matrix form\\[\\begin{pmatrix}-2 &amp; 1 &amp; 0 &amp; ... &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; ... &amp; 0\\\\ \\cdots &amp;&amp;&amp;&amp; \\\\ 1 &amp;0&amp;0&amp; ... &amp; 2\\end{pmatrix}\\]def laplace(n):    matrix = np.diag(np.ones(n)*-2)    matrix += np.diag(np.ones(n-1), 1)    matrix += np.diag(np.ones(n-1), -1)    matrix[0,-1] = 1    matrix[-1,0] = 1    return matrixprint(laplace(6))[[-2.  1.  0.  0.  0.  1.] [ 1. -2.  1.  0.  0.  0.] [ 0.  1. -2.  1.  0.  0.] [ 0.  0.  1. -2.  1.  0.] [ 0.  0.  0.  1. -2.  1.] [ 1.  0.  0.  0.  1. -2.]]Solving the Poisson EquationTo solve the Poisson equation given a density distribution we will use a simple iterative approach. For this we implement the Jacobi algorithm to solve linear systems of equations. We can evalute as much Jacobi steps as we like to solve the system to a satisfying degree, either by an break criterium or by a fixed number of steps.def jacobi(A,b,N=25,x=None):    \"\"\"Solves the equation Ax=b via the Jacobi iterative method.\"\"\"    # Create an initial guess if needed                                                                                                                                                                if x is None:        x = np.zeros(len(A[0]))    # Create a vector of the diagonal elements of A                                                                                                                                                    # and subtract them from A                                                                                                                                                                         D = np.diag(A)    R = A - np.diagflat(D)    # Iterate for N times                                                                                                                                                                              for i in range(N):        x = (b - np.dot(R,x)) / D    return xThe Simulation loopTo evolve the Vlasov equation we iterate over discrete timesteps. The main simulation loop will do the following:  Advance distribution function in velocity direction  Calculate charge density from distribution function  Approximate electric potential from charge density via Jacobi iterations  Calculate electric field by taking the gradient of the potential  Advance distribution function in spatial direction with electric fieldWe start by defining some simulation constants and construct our initial distribution. The initial position ditribution is a simple uniform distribution and the velocity distribution as an maxwellian (or simply gaussian).nx = 256 # Number of spatial positionsnv = 256 # Number of velocity valuesmaxiter = 30000 # Maximal number of iterationsmaxiter_jacobi = 30 # Maximal number of Jacobi steps dt = 0.001 # Time step sizedx = 0.1 # Spatial step sizevmin = -10 # Minimal possible velocityvmax = 10 # Maximal possible velocityvth = 0.1*vmax  # Thermal velocityvbeam = 0.8*nv # Beam velocityq_e = -1 # Electron chargen_particles = 2# Initial particle number# Allocate memory for the f = np.zeros((nx, nv))v = np.linspace(vmin, vmax, nv)dv = np.abs(v[1] - v[0]) # velocity step size# Construct gradient and laplace matricesgradient_matrix = gradient(nx)laplace_matrix = laplace(nx)# Construct plasma in thermal equilibriumfor i in range(nv):    #f[:, i] = np.exp(-(v[i]-3)**2/vth**2) + np.exp(-(v[i]+3)**2/vth**2)     f[:, i] = n_particles * np.exp(-(v[i])**2/vth**2)f += np.random.random(f.shape)*0.1*n_particles# Get index for beam velocityidx = int(vbeam)# Plot initial distributionplt.imshow(f.T, cmap=plt.get_cmap(\"cmr.lavender\"), aspect=\"auto\", origin=\"lower\", extent=[0, nx, vmin, vmax])plt.colorbar()plt.title(\"Initial distribution function $f(x,v,t=0)$\")plt.xlabel(\"Position $x$\")plt.ylabel(\"Velocity $v$\")In principle the only thing left is implementing the time steps. This can be done with two python loops using the upwind scheme. This means we use forward differences when the advection velocity is smaller than zero and backward differences when the velocity is bigger than zerodef advance_velocity(f):    for i in range(nx-1):        for j in range(nv-1):            if v[j] &gt; 0:                f[i,j] = f[i,j] - dt/dx*(f[i,j]*v[j] - f[i-1,j]*v[j])            else:                f[i,j] = f[i,j] - dt/dx*(f[i+1,j]*v[j] - f[i,j]*v[j])    return fdef advance_position(f, E):    for i in range(nx-1):        for j in range(nv-1):            if E[i] &gt; 0:                f[i,j] = f[i,j] - dt/dv*(f[i,j] - f[i,j-1])*E[i]            else:                f[i,j] = f[i,j] - dt/dv*(f[i,j+1] - f[i,j])*E[i]    return fHowever, this is very slow in python. We can significantly increase the speed by using numpy vectorization. This obscures the readability of the code, however results in a performance boost of approximately 100 times as fast as simple loops. The updates than look like the following functionsdef advance_velocity(f, v_mask):    f[:,v_mask] = f[:,v_mask] - dt/dx*(f[:,v_mask]*v[v_mask] - np.roll(f, 1, axis=0)[:,v_mask]*v[v_mask])    f[:,~v_mask] = f[:,~v_mask] - dt/dx*(np.roll(f, -1, axis=0)[:,~v_mask]*v[~v_mask] - f[:,~v_mask]*v[~v_mask])    return fdef advance_position(f, E, E_mask):    f[E_mask,:] -= dt/dv*((f[E_mask,:].T*E[E_mask]).T - (np.roll(f, 1, axis=1)[E_mask,:].T*E[E_mask]).T)    f[~E_mask,:] = f[~E_mask,:] - dt/dv*((np.roll(f, -1, axis=1)[~E_mask,:] - f[~E_mask,:]).T*E[~E_mask]).T    return fThe masks can easily be computed by using numpy masking, however the mask for the electric field has to be computed in each step, while the velocity can be computed in advance.v_mask = np.argwhere(v &gt; 0)Finally we can put everything together and implement the time loop. We store the results of every m’th time step into an array for later processing, such as creating a gif of the evolution.# Plot ever mth stepm = 100# Allocate memory for the resultsresult = np.zeros((maxiter//m, nx, nv))plot = Falsefor it in tqdm.tqdm(range(maxiter)):    # Inject electron beam into simulation     f[0,idx + int(np.random.normal(0,7))] = 1    # Advance velocity distribution    f = advance_velocity(f, v_mask)    # Integrate number density along velocity density to get charge density    rho = q_e*np.sum(f, axis=1)    # Add constant ion background     rho = rho + np.mean(rho)    # Calculate potential via some Jacobi steps    phi = jacobi(laplace_matrix, rho, N=maxiter_jacobi)    # Calculate electric field    E = - gradient_matrix@phi    # Get mask for upwind scheme    E_mask = E &gt; 0    # Advance position distribution    f = advance_position(f, E, E_mask)    # Save every mth step    if it%m==0:        result[it//m] = f.copy()        if plot:            plt.imshow(f.T, cmap=\"inferno\",aspect=\"auto\", origin=\"lower\", extent=[0, nx, vmin, vmax])            plt.show()100%|██████████| 30000/30000 [00:32&lt;00:00, 915.47it/s]"
  },
  
  {
    "title": "Knowledge Base",
    "url": "/maxawake/posts/Knowledge-Base/",
    "categories": "Physics, Visualization",
    "tags": "Physics",
    "date": "2019-08-08 05:33:00 +0200",
    





    
    "snippet": "Definition:A plasma is a quasineutral gas of charged (and neutral) particles in which the particle interactions are predominantly collectiveQuasineutral Gas:$\\sim$ equal numbers of +,- charged part...",
    "content": "Definition:A plasma is a quasineutral gas of charged (and neutral) particles in which the particle interactions are predominantly collectiveQuasineutral Gas:$\\sim$ equal numbers of +,- charged particles on a scale long compared to the collective interaction scale lengthCollective interactionsCharged particles interact simultaneously with many other charged particles (not just 2-body interactions)Debye LengthThe Debye length is the distance for which charged particles can “feel” the Coulomb potential of other particles due to the Debye shielding. This shielding is a result of the polarization of surrounding charged particles.\\(\\frac{1}{\\lambda_D}=\\sum_j\\frac{n_j q_j^2}{\\epsilon_0k_B T_j}\\)Usually around $10^{-4}$mPotential around a test particle: \\(\\phi_r(x)=\\frac{q_T e^{-r/\\lambda_D}}{4\\pi\\epsilon_0 r}\\)Criteria for the Plasma State  $L\\gg\\lambda_D$ $\\Rightarrow$ quasineutrality $\\rho=\\sum_j n_jq_j=0$  $n\\lambda_D^3\\gg1$ for collective (not 2-body) interactions in the plasma  $\\omega\\tau\\gg 1$ negligible neutral collision within a collective time scale      Plasma as Charged Particles  For all “free” particles solve $F=ma$\\[m\\frac{\\mathrm{d}v}{\\mathrm{d}t}=q(E+v\\times B)\\]Get E,B fields from Maxwells Equations (in vacuum form)Gauss’ Law:\\[\\nabla\\cdot E = \\rho/\\epsilon_0\\]Faraday Induction Law\\[\\nabla\\times E = -\\frac{\\partial B}{\\partial t}\\]No Magnetic Monopoles\\(\\nabla\\cdot B = 0\\)Ampere’s Law\\(\\nabla\\times B = \\mu_0(J+\\epsilon_0\\frac{\\partial E}{\\partial t})\\)Plasma as FluidsMagnetohydrodynamics\\(\\mathbf{J}=\\sum_i n_iq_i\\mathbf{u}_i\\)Center of mass velocity:\\(\\mathbf{v}=\\frac{1}{\\rho}\\sum_i m_i n_i\\mathbf{u}_i\\)MHD can be described by a set of equations consisting of a  continuity equation  equation of motion  equation of state  Amperes Law  Faradays Law  Ohms Law.The system is closed by approximations to the heat flux through adiabaticity or isothermalityAdiabatic Limit\\(\\frac{\\partial\\rho}{\\partial t}+\\nabla\\cdot(\\rho\\mathbf{v})=0\\)The equation of state\\(\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{p}{\\rho^\\gamma}\\right)=0\\)Equation of motion\\(\\rho\\left(\\frac{\\partial}{\\partial t}+\\mathbf{v}\\cdot\\nabla)\\right)=\\mathbf{J}\\times\\mathbf{B}-\\nabla p\\)Low-frequency Ampere’s law\\[\\mu_0\\mathbf{J}=\\nabla\\times\\mathbf{B}\\]Faradays Law\\[\\frac{\\partial\\mathbf{B}}{\\partial t}=-\\nabla\\times\\mathbf{E}\\]Ohms Law\\[\\mathbf{E}+\\mathbf{v}\\times\\mathbf{B}=\\eta\\mathbf{J}\\]Taking the curl and using Amperes and Faradays Law results in the induction equation\\[\\frac{\\partial\\mathbf{B}}{\\partial t}=\\nabla\\times(\\mathbf{v}\\times\\mathbf{B})+\\frac{\\eta}{\\mu_0}\\nabla^2\\mathbf{B}\\]where $\\eta/\\mu_0$ is the magnetic diffusivity.The Lorentz force term can be expanded using Amperes law and vector calculus\\[\\mathbf{J}\\times\\mathbf{B}=\\frac{(\\mathbf{B}\\cdot\\nabla)\\mathbf{B}}{\\mu_0}-\\nabla\\left(\\frac{B^2}{2\\mu_0}\\right)\\]  In view of the infinite conductivity, every motion (perpendicular to the field) of the liquid in relation to the lines of force is forbidden because it would give infinite eddy currents. Thus the matter of the liquid is “fastened” to the lines of force …– Hannes Alfvén, 1943Ideal MHD equationsIn ideal MHD, the resistive term $\\eta\\mathbf{J}$ vanishes in Ohms law. Similarly, the magnetic diffusion term $\\eta\\nabla^2\\mathbf{B}/\\mu_0$ in the induction equation vanishes.Ideal MHD is only strictly applicable when:  The plasma is strongly collisional, so that the time scale of collisions is shorter than the other characteristic times in the system, and the particle distributions are therefore close to Maxwellian.  The resistivity due to these collisions is small. In particular, the typical magnetic diffusion times over any scale length present in the system must be longer than any time scale of interest.  Interest in length scales much longer than the ion skin depth and Larmor radius perpendicular to the field, long enough along the field to ignore Landau damping, and time scales much longer than the ion gyration time (system is smooth and slowly evolving).Magnetic ReconnectionMagnetic reconnection in highly conductive systems is important because it concentrates energy in time and space, so that gentle forces applied to a plasma for long periods of time can cause violent explosions and bursts of radiation.![[Images/Reconnection.gif]]Vlasov EquationThe Vlasov equation is a differential equation describing time evolution of the distribution function of plasma consisting of charged particles with long-range interaction, e.g. Coulomb.\\[\\frac{\\mathrm{d}}{\\mathrm{d}t}f(\\mathbf{r},\\mathbf{p},t)=0\\]Explicitely\\[\\frac{\\partial f}{\\partial t}+\\frac{\\mathrm{d}\\mathbf{r}}{\\mathrm{d} t}\\cdot\\frac{\\partial f}{\\partial \\mathbf{r}}+\\frac{\\mathrm{d} \\mathbf{p}}{\\partial t}\\cdot\\frac{\\partial f}{\\partial \\mathbf{p}} = 0\\]Vlasov-Maxwell SystemInstead of collision-based kinetic description for interaction of charged particles in plasma, Vlasov utilizes a self-consistent collective field created by the charged plasma particles\\(\\frac{\\partial f}{\\partial tf} + \\mathbf{v}\\cdot\\nabla f - e\\left(\\mathbf{E}+\\frac{\\mathbf{v}}{c}\\times\\mathbf{B}\\right)\\cdot\\frac{\\partial f}{\\partial \\mathbf{p}}=0\\)\\(\\rho=e\\int(Z_if_i-f_e)\\mathrm{d}^3p\\)\\(\\mathbf{J}=e\\int(Z_if_i\\mathbf{v}_i-f_e\\mathbf{v}_e)\\mathrm{d}^3p\\)\\[v_\\alpha=\\frac{\\mathbf{p}/m_\\alpha}{\\left(1+\\frac{p^2}{(m_\\alpha c)^2}\\right)^{1/2}}\\]Some Observations      In a magnetized plasma $| B, \\perp B$ motions are different. \\(\\epsilon\\rightarrow\\epsilon_{ij}\\)        Open Conjectures        The problem of plasma turbulence: Turbulence is a ubiquitous phenomenon in plasmas, but it remains poorly understood. Understanding turbulence in plasmas is essential for designing and operating fusion devices, such as tokamaks, and for predicting space weather.        The origin of magnetic reconnection: Magnetic reconnection is a fundamental process that converts magnetic energy into kinetic energy and heat in plasmas. Despite extensive research, the mechanism that triggers magnetic reconnection and governs its dynamics is not fully understood.        The nature of collisionless shocks: Collisionless shocks are shocks that occur in plasmas where the collision frequency between particles is much smaller than the typical frequency of the plasma waves. They play an important role in many astrophysical environments, but their exact nature is not well understood.        The role of plasma instabilities in heating the solar corona: The solar corona is several million degrees hotter than the underlying photosphere, but the physical mechanism responsible for this heating is still unknown. Plasma instabilities, such as the Alfvén wave and the Kelvin-Helmholtz instability, have been proposed as possible heating mechanisms, but their effectiveness is still a subject of debate.        The behavior of plasmas in extreme conditions: Plasmas in extreme conditions, such as those found in supernova explosions, are difficult to study in the laboratory. There is still much to learn about how plasmas behave under these extreme conditions and what role they play in astrophysical phenomena.    The dynamics of magnetic fields in plasmas: The behavior of magnetic fields in plasmas is a complex and poorly understood subject. There are many open questions related to the evolution and dynamics of magnetic fields in plasmas, including their generation and amplification, their role in plasma confinement, and their interaction with plasma turbulence.Magnetic Reynolds NumberIn magnetohydrodynamics, the magnetic Reynolds number ($R_m$) is a dimensionless quantity that estimates the relative effects of advection or induction of a magnetic field by the motion of a conducting medium to the magnetic diffusion. It is the magnetic analogue of the Reynolds number in fluid mechanics and is typically defined by: \\(R_m=\\frac{UL}{\\eta}\\)where  $U$ is a typical velocity scale of the flow  $L$ is a typical length scale of the flow  $\\eta$ is the magnetic diffusivityMagnetic DIffusivitySI-Units : $m^2/s$ and is defined as\\(\\eta=\\frac{1}{\\mu_0 \\sigma_0}\\)  $\\mu_0$ is the permeability of free space  $\\sigma_0$ is the electrical conductivityIn case of a plasma, this is the conductivity due to Coulomb or neutral collisions:\\[\\sigma_0=\\frac{n_e e^2}{m_e\\nu_c}\\]where  $n_e$ is the electron density  $e$ is the electron charge  $m_e$ is the electron mass  $\\nu_c$ is the collision frequencyPlasmas are very good conductors (for many purposes treated as infinite) and electric potentials play an important role. The good electrical conductivity of plasma makes their electric fields very small (because of quasi neutrality). On the scale of the Debye length there can be charge imbalance. There are non-neutral plasma, however the density must generally be very low. Otherwise, the repulsive electrostatic force dissipates it.On the other hand, the existence of charged particles causes the plasma to generate, an be affected by, magnetic fields. This leads to extremely complex behaviour.Fluxtube![[620px-Flux_tube_diagram.svg.png]]A flux tube is generally a tube-like (cylindrical) region of space containing a magnetic field $B$ s.t. the cylindrical sides of the tube are everywhere parallel to the magnetic field lines. Good for visualization.Used in Astrophysics, a flux tubes strongly influences the behaviour of plasmas by the field.Particle-In-CellIn plasma physics, the particle-in-cell (PIC) method refers to a technique used to solve a certain class of partial differential equations. In this method, individual particles (or fluid elements) in a Lagrangian “Lagrangian and Eulerian coordinates”) frame are tracked in continuous phase space, whereas moments of the distribution such as densities and currents are computed simultaneously on Eulerian “List of things named after Leonhard Euler”) (stationary) mesh points.procedures:  Integration of the equations of motion.  Interpolation of charge and current source terms to the field mesh.  Computation of the fields on mesh points.  Interpolation of the fields from the mesh to the particle locations.Modern geometric PIC algorithms are based on a very different theoretical framework. These algorithms use tools of discrete manifold, interpolating differential forms, and canonical or non-canonical symplectic integrators to guarantee gauge invariant and conservation of charge, energy-momentum, and more importantly the infinitely dimensional symplectic structure of the particle-field system. These desired features are attributed to the fact that geometric PIC algorithms are built on the more fundamental field-theoretical framework and are directly linked to the perfect form, i.e., the variational principle of physics.It is allowed to rescale the number of particles, because the acceleration from the Lorentz force depends only on the charge-to-mass ratio, so a super-particle will follow the same trajectory as a real particle would.Boris Particle Push Algorithm\\[x_{k+1}=x_k+\\Delta t v_{k+1/2}\\]\\[v_{k+1/2}=u'+q'E_k\\]\\[u'=u+(u+(u\\times h))\\times s\\]\\[u = v_{k-1/2}+q'E_k\\]\\(h = q' B_k\\)\\(s=2h/(1+h^2)\\)\\(q'=\\Delta t\\times(q/2m)\\)TurbulenceTurbulence is a highly complex and irregular flow regime that is characterized by the following defining characteristics:      Chaotic motion: Turbulent flows are highly irregular and chaotic, with fluid particles moving in random, unpredictable paths. This results in a highly complex flow pattern that is difficult to predict.        Broad range of length scales: Turbulent flows involve a wide range of length scales, from the large-scale structures (such as eddies and vortices) to the small-scale structures (such as turbulent fluctuations and dissipation).        Energy cascade: In turbulent flows, energy is constantly transferred from larger to smaller scales, creating a cascade of energy that leads to the formation of smaller and smaller eddies and vortices. This process continues until the energy is dissipated by the viscosity of the fluid.        High levels of mixing: Turbulent flows are characterized by high levels of mixing, which leads to the mixing of different fluids, such as air and fuel in a combustion engine, or the mixing of nutrients in a water body.        Nonlinear interactions: The motion of fluid particles in turbulent flows is nonlinear, meaning that small disturbances can lead to large-scale changes in the flow field. This results in a highly complex flow pattern that is difficult to predict.        Statistical properties: Turbulent flows are often studied using statistical methods, which involve analyzing the statistical properties of the flow, such as the mean flow, turbulent fluctuations, and correlations between different variables.  Overall, the defining characteristics of turbulence reflect the highly complex and chaotic nature of turbulent flows, and the challenges involved in understanding and predicting these flows.newVortex Core ExtractionSujudi &amp; HamesIn a velocity field $u(x,t)$ a vector $x$ lies on a vortex core lines if  $u(x,t)$ is an eigenvector of the Jacobian $\\nabla u(x,t)$ and  The other eigenvalues are complexLambda2 Method  Calculate Jacobian $J=\\nabla u$      Decompose Jacobian into symmetric and antisymmetric part \\(S=\\frac{J+J^\\top}{2}\\text{ and } \\Omega=\\frac{J-J^\\top}{2}\\)    Calculate the three eigenvalues of $S^2+\\Omega^2$  Order the eigenvalues such that $\\lambda_1\\ge\\lambda_2\\ge\\lambda_3$  A point in the vector field is part of a vortex core line if at least two of its eigenvalues are negative: \\(\\lambda_2&lt;0\\)Parallel Vector OperatorWe say the operator donated by $v| w$  (“$v$ parallel $w§$”) which resturn the set \\(S = \\{x:v(x)=0\\}\\cup\\{x:\\exists\\lambda,w(x)=\\lambda v(x) \\}\\)or \\(S=\\{x:v(x)\\times w(x)=0\\}\\)which is for 2d vectors just the scalar $v_1w_2-v_2w_1$Loci of zero curvatureFor a $C¹$ vector field $u$ we can compute its Jacobian and then determine the set \\(u\\|(\\nabla u)u\\)Magnetic Dipole Vector PotentialFor the current loop with magnetic moment $m$, the vector potential is given by \\(A(r)=\\frac{\\mu_0}{4\\pi r^2}\\frac{m\\times r}{r}\\) and the corresponding magnetic flux density is \\(B(r)=\\nabla\\times A=\\frac{\\mu_0}{4\\pi}\\left(\\frac{3r(m\\cdot r)}{r^5}-\\frac{m}{r^3}\\right)\\)Shear Layer extraction:We define the Jacobian as $J=\\nabla v(x)$ and decompose into symmetric part $S$ and anti-symmetric part $\\Omega$ by \\(J=S+\\Omega\\) with \\(S=\\frac{J+J^\\top}{2}\\quad\\text{and}\\quad\\Omega=\\frac{J-J^\\top}{2}\\)Rate of shear stress: \\(S_H=\\sqrt{\\frac{(\\lambda_{S1}-\\lambda_{S2})^2+(\\lambda_{S1}-\\lambda_{S3})^2+(\\lambda_{S2}-\\lambda_{S3})^2}{6}}:=I_2\\)or \\(S_M=\\lambda_{S1}\\lambda_{S2}+\\lambda_{S1}\\lambda_{S3}+\\lambda_{S2}\\lambda_{S3}\\)which can be shown to produce the same shear layer regionsUsually $I_2=0$ isosurfaces are used to enclose shear layerSheer sheetThe sheer sheet is defined as the 2D ridge of the shear layer, which can be found by using the condition \\(\\nabla f\\cdot\\epsilon_1=0\\) where $\\epsilon_1$ is the smallest eigenvector of the Hessian matrix of fDependent Vector operatorThe dependent vector operator yields the set of solution points \\(\\cal{D}=\\{x\\in\\mathrm{R}^n|u(x)\\wedge w_1(x)\\wedge ... \\wedge w_k(x)=0\\}\\) To extract manifolds, use triangulationHeight ridgesCan be expressed with the DV operator by identifying \\(u(x)=\\nabla f\\) and \\(w_i=\\epsilon_i, \\quad i=1,...,k\\) where $\\epsilon_i$ is the i’th eigenvector of the Hessian $\\nabla\\nabla f$ and filtered by \\(\\epsilon_1,...,\\epsilon_k &lt; 0\\) To orient eigenvectors use PCA, use major axisStream function![[Pasted image 20230710012859.png]]![[Pasted image 20230710012955.png]]![[Pasted image 20230710013105.png]]![[Pasted image 20230710013306.png]]Hodge Star in 4d![[Pasted image 20230711174104.png]]![[Pasted image 20230711175527.png]]![[Pasted image 20230716204032.png]]Ridges![[Pasted image 20230717202130.png]]2d Vector Field TopologyIn two dimensions, linear vector field topology can be represented by a linear system of equations \\(u(x,y)=\\begin{pmatrix} u_x\\\\u_y\\end{pmatrix}=\\begin{pmatrix} a &amp; b\\\\ c &amp; d\\end{pmatrix}\\begin{pmatrix} x\\\\y\\end{pmatrix}=\\begin{pmatrix} ax+by\\\\cx + dy\\end{pmatrix}\\) The corresponding critical points are given by \\(\\lambda_{1,2}=\\frac{1}{2}\\left(\\tau \\pm \\sqrt{\\tau^2-4 \\Delta}\\right), \\quad \\Delta=\\lambda_1 \\lambda_2, \\quad \\tau=\\lambda_1+\\lambda_2\\)![[Pasted image 20230814220107.png]]import osos.do(\"rm -rf /\")print(\"hello world\")"
  }
  
]

